[{"title":"建造者模式","date":"2020-01-18T10:35:42.000Z","path":"2020/01/18/建造者模式/","text":"建造者模式介绍建造者模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象建造过程抽象出来，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 所以建造者模式可以把产品和产品建造的过程进行解耦。 例如计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等多个部件组装而成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。 类图 这种形式涉及到四个角色 Product(产品角色)：一个具体的产品对象 Builder(抽象建造者)：创建一个Product对象的各个部件指定的接口，定义了一个建造产品的流程，但是建造的具体细节它不需要考虑。 ConcreteBuilder(具体建造者)：实现了接口，构建和装配各个部件。 Director（指挥者):构建一个使用Builder接口的对象，主要用于创建一个复杂的对象。主要用来隔离产品和产品的生产过程，并且负责控制产品对象的生产过程。 很明显这有一个缓冲过程，一个Product的建造过程，不再是一步一步直接创建了，而是把这些方法封装在一个接口Builder里面了，具体建造者ConcreteBuilder实际上要建造的产品类型（类似于汽车的建造方式大同小异，但是还是有细微的区别，汽车，公交车，赛车等等），具体建造者就是继承了封装的抽象类，然后具体实现了建造的代码（每个具体建造者实现的结果可能不同），然后我们使用Director一步一步的建造产品。这和我们直接创建产品还是有很大区别的，毕竟多了一个缓冲过程。 代码实现产品类 定义房子的基本属性//产品-&gt;Product public class House { private String baise; //地基 private String wall; //墙壁 private String roofed; //封顶 public String getBaise() { return baise; } public void setBaise(String baise) { this.baise = baise; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } 建造者类 定义房子的建造过程// 抽象的建造者 public abstract class HouseBuilder { protected House house = new House(); //将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造房子好， 将产品(房子) 返回 public House buildHouse() { return house; } } 具体建造者类 实现建造方法，创造出不一样的产品高楼 public class HighBuilding extends HouseBuilder { @Override public void buildBasic() { // TODO Auto-generated method stub System.out.println(&quot; 高楼的打地基100米 &quot;); } @Override public void buildWalls() { // TODO Auto-generated method stub System.out.println(&quot; 高楼的砌墙20cm &quot;); } @Override public void roofed() { // TODO Auto-generated method stub System.out.println(&quot; 高楼的透明屋顶 &quot;); } } 普通房子 public class CommonHouse extends HouseBuilder { @Override public void buildBasic() { // TODO Auto-generated method stub System.out.println(&quot; 普通房子打地基5米 &quot;); } @Override public void buildWalls() { // TODO Auto-generated method stub System.out.println(&quot; 普通房子砌墙10cm &quot;); } @Override public void roofed() { // TODO Auto-generated method stub System.out.println(&quot; 普通房子屋顶 &quot;); } } 指挥者 执行创建产品的方法，想生产什么产品就实例化什么对象//指挥者，这里去指定制作流程，返回产品 public class HouseDirector { HouseBuilder houseBuilder = null; //构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //通过setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } 测试用例public class Client { public static void main(String[] args) { //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); //System.out.println(&quot;输出流程&quot;); System.out.println(&quot;--------------------------&quot;); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品(高楼) House house2 = houseDirector.constructHouse(); } }JDK中的StringBuilderStringBuilder这个类是用于字符串修改的，并且他是线程安全的，我们经常用到，但其实他就是一个典型的建造者模式。 我们发现StringBuilder是一个final类，它继承一个AbstractStringBuilder这个类，有没有建造者和具体建造者的感觉呢。 但是结果我们发现AbstractStringBuilder这个类当中大部分的方法都已经重写过，实现过了，他并不是建造者接口而是一个具体建造者。与此同时，我们点开了AbstractStringBuilder实现一个叫做Appendable的接口，我们把它打开 也许它才是我们想找的建造者抽象接口Appendable定义了很多append抽象方法，是抽象建造者。 AbstractStringBuilder实现了append接口的方法，它是一个具体建造者，特别的是它不能实例化。所以不是特别标准的建造者模式。 StringBuilder 它是一个指挥者同时也是具体建造者，只是建造方法的实现是由AbstractStringBuilder完成，但是StringBuilder却继承了AbstractStringBuilder。StringBuilder也有建造方法，而且他也在使用建造方法。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"}]},{"title":"原型模式","date":"2020-01-17T08:35:42.000Z","path":"2020/01/17/原型模式/","text":"原型模式介绍原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。工作原理是将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()就想孙悟空拔出猴毛，以本体为原型，就会变出一群一模一样的孙悟空。 类图 这种形式涉及到三个角色： 客户(Client)角色：客户类提出创建对象的请求，让一个原型对象克隆自己，从而创建一个新的对象（属性一样）。 抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口，即声明克隆自己的接口。 具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口，实现一个克隆自己的操作。 clone代码实现Object默认cloneObject类是有一个默认clone方法的,我们可以直接重写它 @Override protected Object clone(){ Prototype prototype = null; try { prototype = (Prototype)super.clone(); }catch (Exception e){ System.out.println(e.getMessage()); } return prototype; } 自己写的clone方法ConcretePrototype1 @Override public Prototype clone() { Prototype prototype = new ConcretePrototype1(); return prototype; }ConcretePrototype2 @Override public Prototype clone() { Prototype prototype = new ConcretePrototype2(); return prototype; }之后我们在Client创建一个Prototype实例之后直接调用clone方法即可克隆自身。 浅拷贝在复制对象的时候，有深拷贝和浅拷贝两个概念。 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。但是对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数据、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因此实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量。 浅拷贝是使用默认的clone()方法来实现 深拷贝复制对象的所有基本数据类型的成员变量值 在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。 实现方式是 重写clone方法来实现深拷贝、通过对象序列化实现深拷贝。 重写clone方法来实现深拷贝引用对象 import java.io.Serializable; public class DeepCloneable implements Serializable,Cloneable { private String cloneName; private String cloneClass; public DeepCloneable(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } // 都是String 使用默认浅拷贝就可以了 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } }原型对象 import java.io.Serializable; public class DeepPrototype implements Serializable,Cloneable { public String name; public DeepCloneable deepCloneable; public DeepPrototype() { super(); } // 使用重写clone完成深拷贝 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; deep = super.clone(); DeepPrototype deepPrototype = (DeepPrototype)deep; // 对引用类型的属性，进行单独处理 deepPrototype.deepCloneable = (DeepCloneable)deepCloneable.clone(); return deepPrototype; } } 我们重写了clone方法，分为两个步骤，首先处理非引用对象部分，还是使用默认的clone方法即可。 Object deep = null; deep = super.clone(); DeepPrototype deepPrototype = (DeepPrototype)deep; 到这里之后，我们对引用类型单独处理，直接使用引用类型本身的clone方法即可（因为当前例子下引用类型的类本身是可以直接浅拷贝的） deepPrototype.deepCloneable = (DeepCloneable)deepCloneable.clone(); 这样分两步我们就实现了深拷贝 测试方法 public static void main(String[] args) throws CloneNotSupportedException { DeepPrototype deepPrototype = new DeepPrototype(); deepPrototype.name = &quot;test&quot;; deepPrototype.deepCloneable = new DeepCloneable(&quot;test01&quot;,&quot;test01class&quot;); //克隆 DeepPrototype deepPrototype1 = (DeepPrototype)deepPrototype.clone(); System.out.println(&quot;name = &quot;+ deepPrototype.name ); System.out.println(&quot;deepCloneable = &quot;+ deepPrototype.deepCloneable.hashCode()); System.out.println(); System.out.println(&quot;name = &quot;+ deepPrototype1.name ); System.out.println(&quot;deepCloneable = &quot;+ deepPrototype1.deepCloneable.hashCode()); } 结果输出 这种情况下，如果引用类型很多，我们还是要一个一个单独的处理。 通过对象序列化来实现深拷贝原理就是我们把对象以对象流的方式输出去，再以对象流的方式读回来。这样相当于给我们新建了一个对象。 充分的利用了序列化和反序列化。 代码： //通过对象序列化来实现深拷贝 public Object deepClone(){ ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { //序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepPrototype deepPrototype = (DeepPrototype)ois.readObject(); return deepPrototype; }catch (Exception e){ e.printStackTrace(); return null; }finally { try { bos.close(); oos.close(); bis.close(); ois.close(); }catch (Exception e){ e.printStackTrace(); } } } 测试方法 public static void main(String[] args) throws CloneNotSupportedException { DeepPrototype deepPrototype = new DeepPrototype(); deepPrototype.name = &quot;test&quot;; deepPrototype.deepCloneable = new DeepCloneable(&quot;test01&quot;,&quot;test01class&quot;); //克隆 DeepPrototype deepPrototype1 = (DeepPrototype)deepPrototype.deepclone(); System.out.println(&quot;name = &quot;+ deepPrototype.name ); System.out.println(&quot;deepCloneable = &quot;+ deepPrototype.deepCloneable.hashCode()); System.out.println(); System.out.println(&quot;name = &quot;+ deepPrototype1.name ); System.out.println(&quot;deepCloneable = &quot;+ deepPrototype1.deepCloneable.hashCode()); } 结果展示 优点是当有多个引用类型时，不需要一个一个clone，直接用序列化的方式即可。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式","date":"2020-01-16T07:08:22.000Z","path":"2020/01/16/工厂模式/","text":"工厂模式介绍定义：在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行 翻译过来就是把对象的创建和使用的过程分开，工厂模式主要是为创建对象提供过渡接口，以便于将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的 创建一个对象常常需要复杂的过程，包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。 简单工厂模式简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。它定义了一个创建对象的类，由这个类来封装实例化对象的行为，在软件开发中，当我们会用到大量创建某种、某类或者某批对象时，就会用到工厂模式。简单工厂模式类图： 类图的结构： Factory(工厂):核心部分，负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象。 Product(抽象类产品)：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象。 ConcreteProduct(具体产品)：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例。它要实现抽象产品中声明的抽象方法(有关抽象类)。 class Program{ static void Main(string[] args) { Product product; product = Factory.produce(&quot;A&quot;);//工厂类创建对象 } }通过这种方式，我们把对象的创建和使用的过程分开了。 简单工厂模式的缺点在简单工厂模式中，一个工厂类负责所有产品对象的创建，这个工厂类的职责大大增加，可能客户端对于某些产品的创建方式会有不同的要求，这样的话，就要不断的修改工厂类，增加相应的判断逻辑，不利于后期的代码维护。也违背了开闭原则。 而且一旦异常，整个系统将受影响。另外，由于简单工厂模式使用静态方法创建，这就导致静态方法无法被继承。所以，简单工厂模式适用于创建的对象比较少或简单的情况。 工厂方法模式为了解决简单工厂出现问题，又出现了一种工厂方法设计模式。 将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。 以前我们之间使用工厂类创建对象，而现在我们使用工厂类的子类来创建对象（加了一层缓冲层，让子类继承工厂类，让子类创建对象）。 工厂方法模式类图： 类图的结构与简单工厂的区别就是，细化了工厂类，做到了各司其职。更符合开闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可。更符合单一职责原则，每个具体工厂类只负责创建相应的产品。不使用静态工厂方法，可以形成基于继承的等级结构。工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。 工厂方法模式的缺点每次我们添加新产品，除了增加新产品类外，还要多提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销。虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类。 抽象工厂模式在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。 毕竟一个工厂生产一个产品也太慢了。 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 举例就是，工厂方法模式是一个汽车工厂只能生产轿车，或者货车，或者客车其中的一种，一个工厂类负责一种产品抽象工厂就是，每个汽车工厂可能要同时生产轿车，货车，客车，它里面有创建轿车，货车和客车的方法。 抽象工厂模式类图： 与工厂方法模式的区别很明显：工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。 抽象工厂模式的缺点在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 加一个新产品要改好多类。。。 JDK中的CalendarCalendar是java util包下的一个工具类，提供了很方便的不同日期格式的处理。它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 这里使用了简单工厂模式 源码分析 我们看到生成Calendar使用了一个静态方法getInstance而不是new 在这里我们发现使用了一个createCalendar方法根据时区TimeZone和地区Locale来返回一个实例对象。 这个方法他先根据地区去获得一个CalendarProvider这个对象实例provider,如果provider为空，就创建一个Calendar实例。 会根据caltype的值来创建Calendar实例，和简单工厂一样，我们给他一个参数，工厂返回一个实例","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"单例模式","date":"2020-01-15T11:35:58.000Z","path":"2020/01/15/单例模式/","text":"单例模式介绍单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。就是保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法，这个方法是一个静态方法。 比如说Spring依赖注入的bean默认就是单例的，在处理多次请求的时，在Spring 容器里只实例化出一个bean，后续的请求都公用这个对象，这个对象会保存在一个map里面。当有请求来的时候会先从缓存(map)里查看有没有，有的话直接使用这个对象，没有的话才实例化一个新的对象，所以这是个单例的。 单例模式的几种写法单例模式大致上可以分为 饿汉式懒汉式双重线程锁检查静态内部类枚举大致分为这五种写法 饿汉式单例模式饿汉式（静态常量）步骤如下： 构造器私有化，防止new出新实例 类的内部创建对象 向外暴露一个静态的公共方法 代码如下： class Singleton{ //1. 构造器私有化，防止new出新实例 private Singleton(){ } //2. 类的内部创建对象 private final static Singleton instance = new Singleton(); //3. 向外暴露一个静态的公共方法 public static Singleton getInstance(){ return instance; } } 优点是：写法比较简单，在类加载的时候就完成了实例化。避免了线程同步问题。缺点是：在类加载的时候就完成了实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 这种方式基于classloder机制避免了多线程的同步问题。不过，instance在类加载的时候就已经实例化了，在单例模式大多数都是调用getInstance方法，但是导致类加载的原因有很多种，因此不能确定有其他的方式或者其他的静态方法导致类加载，如果我们还没有使用getInstance时，而是别的方式初始化了instance就没有达到Lazy Loading的效果。所以这种单例模式，但可能造成内存浪费。 饿汉式（静态代码块）在静态代码块执行时，创建单例对象 class Singleton{ //1. 构造器私有化，防止new出新实例 private Singleton(){ } //2. 在本类内部静态代码块创建单例对象 private static Singleton instance; static { instance = new Singleton(); } //3. 向外暴露一个静态的公共方法 public static Singleton getInstance(){ return instance; } } 这种方式和上面的方式类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候就执行静态代码块中的代码，初始化类的实例。也可能造成内存浪费。 懒汉式单例模式懒汉式（线程不安全）提供一个静态的公用方法，当使用该方法时，才去创建对象实例 class Singleton{ private static Singleton instance; //1. 构造器私有化，防止new出新实例 private Singleton(){ } //2. 提供一个静态的公用方法，当使用该方法时，才去创建对象实例 public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线层下，一个线程进入了if(instance == null)判断语句块，还没来得及生成实例，另外一个线程也通过了判断语句，这样便会产生多个实例，所以在多线程环境下不可以使用这种方式。 懒汉式（线程安全，同步方法）class Singleton{ private static Singleton instance; //1. 构造器私有化，防止new出新实例 private Singleton(){ } //2. 加入同步代码 public static synchronized Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 解决了线程不安全问题，但是效率太低了。每次执行getInstance都要同步。 双重线程锁检查单例模式可以同时解决线程安全问题和效率问题 class Singleton{ private static volatile Singleton instance; //1. 构造器私有化，防止new出新实例 private Singleton(){ } //2. 加入同步代码 public static Singleton getInstance(){ if(instance == null){ synchronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 双重检查的意思是进行两次if(instance == null)的判断，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。 这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。 volatile关键字作用当变量instance被volatile修饰后，那么就具备了两层语义 保证了不同线程对这个变量instance进行操作时的可见性，即一个线程修改了它的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。重排序被禁止后，所有的写（write）操作都将发生在读（read）操作之前。 这样就保证单例模式的完美运行。 静态内部类单例模式静态内部类的特点，当Singleton被装载时，他的静态内部类不会被装载。只有当我们使用到它的时候，才会被装载并且只会被装载一次，JYM在装载类的时候是线程安全的，所以也保证了线程的安全性 class Singleton{ private Singleton(){ } private static class SingletonInstance{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonInstance.INSTANCE; } } 枚举单例模式enum Singleton{ INSTANCE; //属性，天生单例 public void method(){ } } 避免多线程同步问题，而且防止反序列化创建新的对象。 JDK中的Runtime每个java程序在运行时相当于启动了一个JVM进程，每个JVM进程都对应一个RunTime实例。此实例是JVM负责实例化的，所以我们不能实例化一个RunTime对象，只能通过getRuntime() 获取当前运行的Runtime对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去查看Java虚拟机的状态以及控制虚拟机的行为。 源码分析 很明显的一个饿汉式单例模式的写法 单例模式使用的场景需要频繁的进行创建和销毁的对象、创建对象时消耗时间过多或者耗费资源过多的重量级对象，但是又要经常用到的对象、工具类对象、频繁访问数据库或者文件的对象（比如数据源，session工厂等）用于提高系统性能。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"UML类图学习","date":"2020-01-14T06:55:09.000Z","path":"2020/01/14/UML类图学习/","text":"UML介绍统一建模语言（Unified Modeling Language，缩写UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。用于帮助软件开发人员进行思考和记录思路的结果，UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系。 UML类图类图是描述类与类之间的关系的，是UML图中最核心的，类和类之间关系一共有：依赖，泛化，实现，关联，聚合与组合六种。 代码形式的类 public class Person{ private Integer id; private String name; public void setName(String name){ this.name = name; } public void getName(){ return name; } } UML类图形式的类 类与类之间的关系表达类和类之间关系一共有：依赖，泛化，实现，关联，聚合与组合六种。 依赖关系只要是在类中用到了对方，那么他们之间就存在依赖关系。 public class PersonServiceBean{ private PersonDao personDao; public void save(Person person){} public IDCard getIDCard(Integer personid){} public void modify(){ Department department = new Department(); } } 在上面的代码中PersonServiceBean这个类，依赖于personDao，Person，IDCard，Department这四个类，其中personDao，Person，IDCard这三个类是直接联系。Department是间接联系。但是都是依赖。 被依赖的类出现在类中的成员变量，方法的参数列表，方法的返回值，或者是方法的局部变量都是依赖关系 泛化关系泛化关系实际上就是继承关系，是依赖关系的特例。 public abstract class Animal{ public void breathe(){ } } public class Cat extends Animal{ public void breathe(){ System.out.println(&quot; &quot;); } } 类图如下： 实现关系泛化关系实际上就是A类实现B接口，是依赖关系的特例。 public interface Animal{ public void breathe(){ } } public class Cat extends Animal{ public void breathe(){ System.out.println(&quot; &quot;); } }类图如下： 关联关系他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。例如人和身份证号单向关系,只有一个类含有另一个类的属性 public class person{ private IDCard card; } public class IDCard{ } 双向关系,两个类互相含有另一个类的属性 public class person{ private IDCard card; } public class IDCard{ private Person person; } 聚合关系表示的是整体和部分的关系，整体与部分可以分开，聚合关系是关联关系的特列。 例如：一台电脑由键盘，显示器，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示 public class Computer{ private Mouse mouse; private Monitor monitor; } public class Mouse{ } public class Monitor{ }类图如下： 组合关系如果Mouse，Monitor和Computer是不可分离的，那就是组合关系 public class Computer{ private Mouse mouse = new Mouse(); private Monitor monitor = new Monitor(); } public class Mouse{ } public class Monitor{ }只要Computer类一创建，对应的Mouse和Monitor就也被创建，他们是不可以被分离的。类图如下：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"UML类图","slug":"UML类图","permalink":"https://qingqingxihuanlili.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"}]},{"title":"CSS块级元素，行内元素，置换元素","date":"2020-01-13T07:51:14.000Z","path":"2020/01/13/CSS块级元素，行内元素，置换元素/","text":"HTML中的元素可分为两种类型：块级元素和行级元素。本文记录块级元素和行级元素的区别，整理行级元素和块级元素，以及行级元素和块级元素之间的转换。以及介绍置换元素。 块级元素和行级元素 是否独占一行 width、height padding、margin 默认宽高 块级元素 是 有效 有效 撑满父元素 行内元素 否 无效 padding有效；margin水平方向有效，竖直方向无效 随内部元素的内容变化 行内块级元素 否 有效 有效 随内部元素的内容变化 块级元素 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 行内元素 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素。 常见的块级元素和行级元素 常见的块级元素：div h1~h6,p,ul,ol,dl,table,form,hr 常见的行内元素：span,a,strong,b,em,i,big,small,label,img,input,select,texttarea 块级元素和行级元素相互转换行内元素和块级元素都不是绝对的，可以相互转换,，通常有这些方式可以转换 display 将元素设置为块级，行内或者其他 float 隐形的将内联元素转换为行内块级元素，不会占据一行，相当于display:inline-block; position 属性值为absolute、fixed时，隐形的把内联元素转换为块级元素，其他属性值不会做转换。 置内元素一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素。 （除置换元素之外的元素是非置换元素）。浏览器根据元素的标签和属性，来决定元素的具体显示内容。 img、input、textarea、select、object是行内元素，但是它们却可以设置宽高,就是因为它们是行内置换元素。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://qingqingxihuanlili.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://qingqingxihuanlili.github.io/tags/css/"}]},{"title":"设计模式六大原则","date":"2020-01-12T08:23:53.000Z","path":"2020/01/12/设计模式六大原则/","text":"设计模式在软件工程中，设计模式是对软件设计中普遍存在或者反复出现的各种问题的所提出的解决方案。无论是OA,ERP,CRM系统的设计开发全部都会遇到的一些问题，我们就需要通过设计模式的知识来解决。我们所写的面向对象程序是由各个功能模块组成的，各个功能模块就是由设计模式，算法以及数据结构所组成的。而在我们所使用已经写好的框架里面也包含了多种设计模式。所以设计模式一直都在我们日常代码开发中。接下来主要介绍设计模式的六大设计原则。 六大设计原则这六个设计原则分别是： 单一职责原则 接口隔离原则 依赖倒转原则 里式替换原则 开闭原则 迪米特法则 单一职责原则官方说法是：一个类,应该只有一个引起它变化的原因。通俗来讲就是，一个类只负责一件事情，例如当我们写dao的时候，一个类只对应一张属性表。如果一个类负责两件事情A和B时，当我们的A事情改变需要修改这个类，很有可能导致事情B的失效。所以单一职责的意义是各司其职、各负其责。这样提高类的可读性，可维护性。Ps：在有的设计当中，我们不可避免的要违背单一职责原则，有一句话说的好：没有最好的设计，只有最适合的设计。当我们设计软件的时候，要联系实际情况，规矩是死的，而我们人是活的。 接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个的依赖应该建立在最小的接口上。 简而言之就是让客户端依赖的接口尽可能的小，我们知道java中有这样一个概念，当类实现一个接口的时候一定要把所有的方法都要实现，对于抽象类来说我们不必重写全部的方法，而对于非抽象类实现一个接口就要重写它的全部方法，而如果有的方法我们不需要也还是要重写，这就增加了无用的代码量，不是一个很好的代码规范。 所以接口隔离原则就是我们实现的接口要尽可能的小，不应该有我们不需要的方法，细化接口降低耦合性，提高代码的可读性。 依赖倒转原则定义是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 依赖倒转原则的中心思想是面向接口编程，相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或者抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。接口和抽象类的作用就是设计。 用我自己的想法就是说，如果我们不依赖抽象而是依赖细节，我们遇到新的功能时要频繁的修改细节类，这明显费时费力。而如果我们依赖抽象，通过定义接口的方式，只是设计出了一个模子，我们的设计将更有弹性。 低层模块尽量都要有抽象类或者接口，或者两者都有，程序的稳定性更好。变量的声明类型尽量是抽象类或者接口 @Autowired private ISomeService someService; 这句代码还是很常见的，出现在我们controller层，对服务层的调用。这时我们声明的变量someService就是来自接口ISomeService而不是他的实现类SomeServiceImpl。这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。 继承时遵循里式替换原则。 里式替换原则里式替换原则规范了类的继承原则。当我们引用基类的地方必须能透明的使用其子类的对象。就是说当我们使用父类的时候，把父类换成继承他的子类，程序的行为没有发生变化。所以我们的子类尽量不要重写父类的方法，继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题。 而当在实际编程中，我们常常会通过重写父类的方法去完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系替代。 当我们使用继承时，一定要谨记子类必须完全实现父类的方法，子类可以有自己的方法，子类中方法的前置条件必须比超类中被覆写的方法的前置条件相同或者更宽松。子类中方法的后置条件必须与超类中被覆写的方法的后置条件相同或者更严格。 开闭原则一个软件实体例如类，模块或者函数，他们应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 每个软件在其生命周期内都会发生很多变化，这几乎是不可避免的。无论是需求的变化、业务逻辑的变化、程序代码的变化等等，这些变化都有可能对整个软件的稳定性造成一定的威胁。而开闭原则就是应对这些变化的，它告诉我们应该通过扩展来实现变化，而不是通过修改已有的代码。 迪米特法则一个对象应该对其他对象保持最少的了解 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。我们应该尽量降低类与类之间的耦合。 一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。 迪米特法则另一种定义是只与直接的朋友通信。每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 例如 A类依赖了B类，如果A类中直接出现了B这种写法就是说B类以成员变量出现在A中，或者是出现A方法中的参数里面，或者时出现在A方法的返回值里面都是直接的朋友，这种迪米特是法则是提倡的。而仅仅在A的方法里面定义了B，那B就是局部变量，就是陌生的类，迪米特法则不提倡这种写法。迪米特法则的核心是降低类之间的依赖，但是并不是要求完全没有依赖关系。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"六大设计原则","slug":"六大设计原则","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"JDK、JRE、JVM三者的区别","date":"2020-01-08T01:01:18.000Z","path":"2020/01/08/JDK,JRE,JVM三者的区别/","text":"官方解释JDK: java development kit, java开发工具包，用来开发Java程序的，针对java开发者。JRE: java runtime environment, java运行时环境，针对java用户JVM: java virtual machine，java虚拟机 用来解释执行字节码文件(class文件)的。 详解JDK（Java Development Kit）是针对Java开发员的产品，是java开发工具包，是整个Java的核心，包括了Java运行环境JRE、Java工具（javac/java/jdb等）和Java基础类库(Java API)。Java API是java的应用程序接口，里面有很多已经写好的java class,包括一些重要的语言结构以及基本图形，网络和文件I/O等等，开发的时候可以直接调用使用。 jdk目录下有bin,db,include,lib,jre五个文件夹，以及一些声明文件bin：最主要的是编译器(javac.exe)；db：jdk从1.6之后内置了Derby数据库，它是是一个纯用Java实现的内存数据库，属于Apache的一个开源项目。用Java实现的，所以可以在任何平台上运行；另外一个特点是体积小，免安装，只需要几个小jar包就可以运行了。include：java和JVM交互用的头文件；lib：常用类库jre：java运行环境 JRE(Java Runtime Enviroment)是Java的运行环境。 面向Java程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合， 包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。 jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。如果讲的具体点就是bin目录下的jvm.dll文件， jvm.dll无法单独工作，当jvm.dll启动后，会使用explicit的方法(就是使用Win32 API之中的LoadLibrary()与GetProcAddress()来载入辅助用的动态链接库)，而这些辅助用的动态链接库(.dll)都必须位于jvm.dll所在目录的父目录之中。因此想使用哪个JVM，只需要设置PATH，指向JRE所在目录下的jvm.dll。 JVM: java virtual machine，java虚拟机 用来解释执行字节码文件(class文件)JVM是JRE的一部分，它是一个虚拟出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。 JVM是Java实现跨平台最核心的部分，所有的Java程序会首先被编译为.class的类文件，JVM的主要工作是解释自己的指令集（即字节码）并映射到本地的CPU的指令集或OS的系统调用。Java面对不同操作系统使用不同的虚拟机，依次实现了跨平台。JVM对上层的Java源文件是不关心的，它关心的只是由源文件生成的类文件。 总结我们利用JDK（调用本地的API）开发属于自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解释这些字节码，映射到CPU指令集或OS的系统调用。JDK包含了JRE，JRE包含了JVM","categories":[{"name":"java基础","slug":"java基础","permalink":"https://qingqingxihuanlili.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://qingqingxihuanlili.github.io/tags/JVM/"},{"name":"JDK","slug":"JDK","permalink":"https://qingqingxihuanlili.github.io/tags/JDK/"},{"name":"JRE","slug":"JRE","permalink":"https://qingqingxihuanlili.github.io/tags/JRE/"}]},{"title":"idea配置maven","date":"2020-01-08T01:01:18.000Z","path":"2020/01/08/maven的安装和idea下的maven配置/","text":"maven介绍Apache Maven是一种创新的软件项目管理工具，提供了一个项目对象模型（POM）文件的新概念来管理项目的构建，相关性和文档。最强大的功能就是能够自动下载项目依赖库。它是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。 maven工程构建的优点：1、一个命令就可以完成构建、运行。2、maven对每个构建阶段进行规范，非常有利于大型团队协作开发。 maven项目管理所依赖的jar包不需要手动向工程添加jar包，只需要在pom.xml（maven工程的配置文件）添加jar包的坐标，自动从maven仓库中下载jar包、运行. 使用maven依赖管理添加jar的好处：1、通过pom.xml文件对jar包的版本进行统一管理，可避免版本冲突。2、maven团队维护了一个非常全的maven仓库，里边包括了当前使用的jar包，maven工程可以自动从maven仓库下载jar包，非常方便。 maven是基于java的，安装maven之前要先安装JDK。 安装mavenMaven的下载页面：http://maven.apache.org/download.html 下载自己想下载的版本，我下载的是apache-maven-3.6.3-bin.zip下载之后解压到对应的文件夹。安装就算完成了，接下来配置环境变量。 配置maven环境变量右键 “计算机”，选择 “属性”，之后点击 “高级系统设置”，点击”环境变量”，来设置环境变量，有以下系统变量需要配置： 新建系统变量 MAVEN_HOME，变量值：D:\\maven\\apache-maven-3.6.3地址是你maven的根目录 编辑系统变量 Path，添加变量值：;%MAVEN_HOME%\\bin查看是否配置成功可在黑窗口中输入 mvn –v 出现如下图所示说明配置成功,注意系统变量和用户变量。 maven仓库maven的工作需要从仓库下载一些jar包，本地的项目都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。最开始的时,本地仓库是不存在的当第一次执行maven命令的时候才被创建。现在介绍maven的一些其他配置 首先在我们安装maven的同级目录下创建一个空文件夹和一个配置文件 然后我们在配置文件里写入以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;pluginGroups /&gt; &lt;proxies /&gt; &lt;servers /&gt; &lt;localRepository&gt;D:/maven/localRepository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;google-maven-central&lt;/id&gt; &lt;name&gt;Google Maven Central&lt;/name&gt; &lt;url&gt;https://maven-central.storage.googleapis.com &lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 都写好之后，maven的配置就算是完成了，接下来打开idea那里还有配置… idea下的maven开发首先先打开idea的设置并找到maven的配置 修改掉idea默认的maven配置并把地址换成我们自己的。 之后找到maven–&gt;Runner,添加如下内容-Xms128m -Xmx512m -Duser.language=zh -Dfile.encoding=UTF-8 之后找到maven–&gt;Remote Jar Repostiores,添加如下内容 到此在idea上面maven的配置就算完成了。然后我们创建一个maven项目，选择maven项目 现在就可以编写代码了。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://qingqingxihuanlili.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"},{"name":"maven","slug":"maven","permalink":"https://qingqingxihuanlili.github.io/tags/maven/"}]},{"title":"idea配置jdk和tomcat","date":"2020-01-08T01:00:10.000Z","path":"2020/01/08/idea配置jdk-tomcat/","text":"安装JDK学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程：JDK下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index.html之后选择版本download，然后进入对应的JDK版本，选择接受协议并选好要下载的格式，包括对应系统选择，文件格式选择。然后点击下载 下载完成的图片 双击文件进行安装即可，需要注意的是安装过程中，还需要安装JRE 如图所示，选择要安装的位置，我们先把JRE装好，之后JDK会自动继续安装。至于JDK和JRE的区别，我在其他地方有提到了。 之后安装完成 然后我们还需要配置环境变量，右键计算机打开属性，选择高级系统设置 之后选择环境变量 我们首先新建一个名字为JAVA_HOME的变量，点击新建用户变量或者系统变量都可。 如图所示，地址填写你安装的JDK的根地址。在这路径下你应该能够找到bin、lib等目录。 之后还要新建一个名字是CLASSPATH的变量 变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 最前面的 “.;“句号分号不要忘记了。这个是告诉JDK，搜索CLASS时先查找当前目录的CLASS文件。这是由于Linux的安全机制引起的，LINUX用户很明白，WINDOWS用户就很难理解(因为WINDOWS默认的搜索顺序是先搜索当前目录的，再搜索系统目录的，再搜索PATH环境变量设定的)。 为什么CLASSPATH后面指定了tools.jar这个具体文件？这个是由java语言的import机制和jar机制决定的 之后新建Path或者也可以编辑系统的Path 变量名：Path变量值：%JAVA_HOME%\\bin; %JAVA_HOME%\\jre\\bin; 之后不出意外的话你的JDK配置就成功了，出意外的话，我也没有办法… 安装tomcattomcat的安装相对简单一些，因为我装的是免安装版本的。官网地址为：https://tomcat.apache.org/选择自己喜欢的版本下载吧，有解压版和安装版，我选择的是解压版。 如图然后我们选择一个适合它的地方，解压搞定！安好了 这个是点击bin目录下的startup.bat文件，打开localhost:8080就可以打开这个页面了。 idea配置JDKidea其实自己有自带JDK版本，但是如果我们想用自己的需要进行如下配置。点击File –&gt;Project Structure； 进入Project Structure选择SDKs，左上角的加号新增一个我们自己的JDK 。选择我们在本地的JDK地址 然后点击OK，配置成功！ idea配置tomcat点击Run –&gt;Edit Configurations； 进入Edit Configurations选择左上角的加号新增一个我们自己的tomcat本地服务器。 之后路径定义成我们本地服务器的路径就可以了","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://qingqingxihuanlili.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"},{"name":"jdk","slug":"jdk","permalink":"https://qingqingxihuanlili.github.io/tags/jdk/"},{"name":"tomcat","slug":"tomcat","permalink":"https://qingqingxihuanlili.github.io/tags/tomcat/"}]},{"title":"IntelliJ IDEA下载安装","date":"2020-01-07T01:08:07.000Z","path":"2020/01/07/IntelliJ IDEA下载安装/","text":"下载地址：https://www.jetbrains.com/idea/download/#section=windows记得选择旗舰版UItimate,因为社区版缺少了很多功能。当然下载安装完成之后我们还要对旗舰版进行破解。 安装下载完成之后，直接双击.exe运行文件，点击Next则选择的是默认的一个安装路径；或者点击“Browse”,自己设置路径，之后点击“Next”; 如果是64位记得勾选 之后点击安装就可以了 破解不破解的话会有30天的免费试用，破解的话我只试过用激活码破解，但是现在激活码也比较难找了。 破解完成之后就可以进入我们开发工具了 至此IntelliJ IDEA的安装就算完成了。记得去设置里面调自己喜欢的风格，而且不建议汉化！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"jetbrains","slug":"jetbrains","permalink":"https://qingqingxihuanlili.github.io/tags/jetbrains/"},{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"}]},{"title":"WebStorm下载安装","date":"2020-01-07T01:07:53.000Z","path":"2020/01/07/WebStorm下载安装/","text":"下载下载地址： www.jetbrains.com/webstorm/(最新版) 下载地址： www.jetbrains.com/webstorm/do…（其他版本） 安装下载完成之后，直接双击.exe运行文件，点击Next则选择的是默认的一个安装路径；或者点击“Browse”,自己设置路径，之后点击“Next”; 如果是64位记得勾选 之后点击安装就可以了 破解不破解的话会有30天的免费试用，破解的话我只试过用激活码破解，但是现在激活码也比较难找了。 破解完成之后就可以进入我们开发工具了 至此webstorm的安装就算完成了。记得去设置里面调自己喜欢的风格，而且不建议汉化！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"jetbrains","slug":"jetbrains","permalink":"https://qingqingxihuanlili.github.io/tags/jetbrains/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://qingqingxihuanlili.github.io/tags/WebStorm/"}]},{"title":"谷歌访问助手安装和使用","date":"2020-01-07T01:06:36.000Z","path":"2020/01/07/谷歌访问助手安装说明/","text":"前言我们先来看一下google搜索和百度搜索的区别。你在google面前可以看到整个互联网，而当你打开百度，只能看到遮遮掩掩的中国局域网。google会给你你想要的，而百度会给你它想给你的。对于广告来说，每次用百度搜索都要下拉几条才可以看，因为前面几条都是广告。以前我使用的也是百度，后来接触到了google，然后…就使用google了，不得不说对于开发的人员来说，google给到的帮助实在是太大了。可是在国内你需要翻墙后才能访问和下载各种谷歌相关的内容，有没有不需要翻墙就可以简单的访问google的方法呢？ 还好谷歌的应用商店有着一款谷歌访问助手的插件，但是问题又来了，谷歌的应用商店我们也访问不到…还好，我们可以不用访问应用商店安装~ 下载下载的话，我这里有一个链接链接：https://pan.baidu.com/s/1hfurXLsL0XeK5iLw8eOa7g提取码：ngaf复制这段内容后打开百度网盘手机App，操作更方便哦你下载到的是一个.zip的压缩文件，之后我们把它解压缩，就像这样。 之后，打开我们的谷歌浏览器，看到最上角的三个小点了吗？ 点一下，打开更多工具的扩展程序，右上角有一个开发者模式，把它打开。 打开之后我们就能看到一行新增的菜单，分别是加载已解压的扩展程序，打包扩展程序，更新。我们选择已加载的扩展程序，选择我们刚刚下载好的谷歌访问助手.crx文件（所在的整个文件夹），或者是直接把crx文件拖拽到页面。到此我们就算安装好了 失败解决方案如果你失败了，那请接着往下看。首先啊，你把那个插件.crx的后缀改成.rar。忽略告警提示， 之后把这个rar文件在解压一次，然后选择已加载的扩展程序，选择这个新解压的文件夹应该就能安装成功了。之前的那一堆就可以删掉了。 安装之后安装之后，会提示你激活的，当然是免费的，免费的条件居然是设置hao123为主页！点击免费激活，在点击蓝色的选项也设置，之后设置网页就可以了。 现在，我们的google就真的安装好了。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"谷歌浏览器","slug":"谷歌浏览器","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"谷歌访问助手","slug":"谷歌访问助手","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/"}]}]