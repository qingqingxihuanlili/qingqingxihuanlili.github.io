[{"title":"UML类图学习","date":"2020-05-25T06:55:09.000Z","path":"2020/05/25/UML类图学习/","text":"UML介绍统一建模语言（Unified Modeling Language，缩写UML）是非专利的第三代建模和规约语言。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。用于帮助软件开发人员进行思考和记录思路的结果，UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系。 UML类图类图是描述类与类之间的关系的，是UML图中最核心的，类和类之间关系一共有：依赖，泛化，实现，关联，聚合与组合六种。 代码形式的类 public class Person{ private Integer id; private String name; public void setName(String name){ this.name = name; } public void getName(){ return name; } } UML类图形式的类 类与类之间的关系表达类和类之间关系一共有：依赖，泛化，实现，关联，聚合与组合六种。 依赖关系只要是在类中用到了对方，那么他们之间就存在依赖关系。 public class PersonServiceBean{ private PersonDao personDao; public void save(Person person){} public IDCard getIDCard(Integer personid){} public void modify(){ Department department = new Department(); } } 在上面的代码中PersonServiceBean这个类，依赖于personDao，Person，IDCard，Department这四个类，其中personDao，Person，IDCard这三个类是直接联系。Department是间接联系。但是都是依赖。 被依赖的类出现在类中的成员变量，方法的参数列表，方法的返回值，或者是方法的局部变量都是依赖关系 泛化关系泛化关系实际上就是继承关系，是依赖关系的特例。 public abstract class Animal{ public void breathe(){ } } public class Cat extends Animal{ public void breathe(){ System.out.println(&quot; &quot;); } } 类图如下： 实现关系泛化关系实际上就是A类实现B接口，是依赖关系的特例。 public interface Animal{ public void breathe(){ } } public class Cat extends Animal{ public void breathe(){ System.out.println(&quot; &quot;); } }类图如下： 关联关系他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。例如人和身份证号单向关系,只有一个类含有另一个类的属性 public class person{ private IDCard card; } public class IDCard{ } 双向关系,两个类互相含有另一个类的属性 public class person{ private IDCard card; } public class IDCard{ private Person person; } 聚合关系表示的是整体和部分的关系，整体与部分可以分开，聚合关系是关联关系的特列。 例如：一台电脑由键盘，显示器，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示 public class Computer{ private Mouse mouse; private Monitor monitor; } public class Mouse{ } public class Monitor{ }类图如下： 组合关系如果Mouse，Monitor和Computer是不可分离的，那就是组合关系 public class Computer{ private Mouse mouse = new Mouse(); private Monitor monitor = new Monitor(); } public class Mouse{ } public class Monitor{ }只要Computer类一创建，对应的Mouse和Monitor就也被创建，他们是不可以被分离的。类图如下：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"UML类图","slug":"UML类图","permalink":"https://qingqingxihuanlili.github.io/tags/UML%E7%B1%BB%E5%9B%BE/"}]},{"title":"CSS块级元素，行内元素，置换元素","date":"2020-05-23T07:51:14.000Z","path":"2020/05/23/CSS块级元素，行内元素，置换元素/","text":"HTML中的元素可分为两种类型：块级元素和行级元素。本文记录块级元素和行级元素的区别，整理行级元素和块级元素，以及行级元素和块级元素之间的转换。以及介绍置换元素。 块级元素和行级元素 是否独占一行 width、height padding、margin 默认宽高 块级元素 是 有效 有效 撑满父元素 行内元素 否 无效 padding有效；margin水平方向有效，竖直方向无效 随内部元素的内容变化 行内块级元素 否 有效 有效 随内部元素的内容变化 块级元素 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 行内元素 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素。 常见的块级元素和行级元素 常见的块级元素：div h1~h6,p,ul,ol,dl,table,form,hr 常见的行内元素：span,a,strong,b,em,i,big,small,label,img,input,select,texttarea 块级元素和行级元素相互转换行内元素和块级元素都不是绝对的，可以相互转换,，通常有这些方式可以转换 display 将元素设置为块级，行内或者其他 float 隐形的将内联元素转换为行内块级元素，不会占据一行，相当于display:inline-block; position 属性值为absolute、fixed时，隐形的把内联元素转换为块级元素，其他属性值不会做转换。 置内元素一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素。 （除置换元素之外的元素是非置换元素）。浏览器根据元素的标签和属性，来决定元素的具体显示内容。 img、input、textarea、select、object是行内元素，但是它们却可以设置宽高,就是因为它们是行内置换元素。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://qingqingxihuanlili.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://qingqingxihuanlili.github.io/tags/css/"}]},{"title":"设计模式六大原则","date":"2020-05-20T08:23:53.000Z","path":"2020/05/20/设计模式六大原则/","text":"设计模式在软件工程中，设计模式是对软件设计中普遍存在或者反复出现的各种问题的所提出的解决方案。无论是OA,ERP,CRM系统的设计开发全部都会遇到的一些问题，我们就需要通过设计模式的知识来解决。我们所写的面向对象程序是由各个功能模块组成的，各个功能模块就是由设计模式，算法以及数据结构所组成的。而在我们所使用已经写好的框架里面也包含了多种设计模式。所以设计模式一直都在我们日常代码开发中。接下来主要介绍设计模式的六大设计原则。 六大设计原则这六个设计原则分别是： 单一职责原则 接口隔离原则 依赖倒转原则 里式替换原则 开闭原则 迪米特法则 单一职责原则官方说法是：一个类,应该只有一个引起它变化的原因。通俗来讲就是，一个类只负责一件事情，例如当我们写dao的时候，一个类只对应一张属性表。如果一个类负责两件事情A和B时，当我们的A事情改变需要修改这个类，很有可能导致事情B的失效。所以单一职责的意义是各司其职、各负其责。这样提高类的可读性，可维护性。Ps：在有的设计当中，我们不可避免的要违背单一职责原则，有一句话说的好：没有最好的设计，只有最适合的设计。当我们设计软件的时候，要联系实际情况，规矩是死的，而我们人是活的。 接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个的依赖应该建立在最小的接口上。 简而言之就是让客户端依赖的接口尽可能的小，我们知道java中有这样一个概念，当类实现一个接口的时候一定要把所有的方法都要实现，对于抽象类来说我们不必重写全部的方法，而对于非抽象类实现一个接口就要重写它的全部方法，而如果有的方法我们不需要也还是要重写，这就增加了无用的代码量，不是一个很好的代码规范。 所以接口隔离原则就是我们实现的接口要尽可能的小，不应该有我们不需要的方法，细化接口降低耦合性，提高代码的可读性。 依赖倒转原则定义是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 依赖倒转原则的中心思想是面向接口编程，相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。使用接口或者抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。接口和抽象类的作用就是设计。 用我自己的想法就是说，如果我们不依赖抽象而是依赖细节，我们遇到新的功能时要频繁的修改细节类，这明显费时费力。而如果我们依赖抽象，通过定义接口的方式，只是设计出了一个模子，我们的设计将更有弹性。 低层模块尽量都要有抽象类或者接口，或者两者都有，程序的稳定性更好。变量的声明类型尽量是抽象类或者接口 @Autowired private ISomeService someService; 这句代码还是很常见的，出现在我们controller层，对服务层的调用。这时我们声明的变量someService就是来自接口ISomeService而不是他的实现类SomeServiceImpl。这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。 继承时遵循里式替换原则。 里式替换原则里式替换原则规范了类的继承原则。当我们引用基类的地方必须能透明的使用其子类的对象。就是说当我们使用父类的时候，把父类换成继承他的子类，程序的行为没有发生变化。所以我们的子类尽量不要重写父类的方法，继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题。 而当在实际编程中，我们常常会通过重写父类的方法去完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系替代。 当我们使用继承时，一定要谨记子类必须完全实现父类的方法，子类可以有自己的方法，子类中方法的前置条件必须比超类中被覆写的方法的前置条件相同或者更宽松。子类中方法的后置条件必须与超类中被覆写的方法的后置条件相同或者更严格。 开闭原则一个软件实体例如类，模块或者函数，他们应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 每个软件在其生命周期内都会发生很多变化，这几乎是不可避免的。无论是需求的变化、业务逻辑的变化、程序代码的变化等等，这些变化都有可能对整个软件的稳定性造成一定的威胁。而开闭原则就是应对这些变化的，它告诉我们应该通过扩展来实现变化，而不是通过修改已有的代码。 迪米特法则一个对象应该对其他对象保持最少的了解 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。我们应该尽量降低类与类之间的耦合。 一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。 迪米特法则另一种定义是只与直接的朋友通信。每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 例如 A类依赖了B类，如果A类中直接出现了B这种写法就是说B类以成员变量出现在A中，或者是出现A方法中的参数里面，或者时出现在A方法的返回值里面都是直接的朋友，这种迪米特是法则是提倡的。而仅仅在A的方法里面定义了B，那B就是局部变量，就是陌生的类，迪米特法则不提倡这种写法。迪米特法则的核心是降低类之间的依赖，但是并不是要求完全没有依赖关系。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://qingqingxihuanlili.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"六大设计原则","slug":"六大设计原则","permalink":"https://qingqingxihuanlili.github.io/tags/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"JDK、JRE、JVM三者的区别","date":"2020-01-08T01:01:18.000Z","path":"2020/01/08/JDK,JRE,JVM三者的区别/","text":"官方解释JDK: java development kit, java开发工具包，用来开发Java程序的，针对java开发者。JRE: java runtime environment, java运行时环境，针对java用户JVM: java virtual machine，java虚拟机 用来解释执行字节码文件(class文件)的。 详解JDK（Java Development Kit）是针对Java开发员的产品，是java开发工具包，是整个Java的核心，包括了Java运行环境JRE、Java工具（javac/java/jdb等）和Java基础类库(Java API)。Java API是java的应用程序接口，里面有很多已经写好的java class,包括一些重要的语言结构以及基本图形，网络和文件I/O等等，开发的时候可以直接调用使用。 jdk目录下有bin,db,include,lib,jre五个文件夹，以及一些声明文件bin：最主要的是编译器(javac.exe)；db：jdk从1.6之后内置了Derby数据库，它是是一个纯用Java实现的内存数据库，属于Apache的一个开源项目。用Java实现的，所以可以在任何平台上运行；另外一个特点是体积小，免安装，只需要几个小jar包就可以运行了。include：java和JVM交互用的头文件；lib：常用类库jre：java运行环境 JRE(Java Runtime Enviroment)是Java的运行环境。 面向Java程序的使用者，而不是开发者。如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合， 包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。 jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。如果讲的具体点就是bin目录下的jvm.dll文件， jvm.dll无法单独工作，当jvm.dll启动后，会使用explicit的方法(就是使用Win32 API之中的LoadLibrary()与GetProcAddress()来载入辅助用的动态链接库)，而这些辅助用的动态链接库(.dll)都必须位于jvm.dll所在目录的父目录之中。因此想使用哪个JVM，只需要设置PATH，指向JRE所在目录下的jvm.dll。 JVM: java virtual machine，java虚拟机 用来解释执行字节码文件(class文件)JVM是JRE的一部分，它是一个虚拟出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。 JVM是Java实现跨平台最核心的部分，所有的Java程序会首先被编译为.class的类文件，JVM的主要工作是解释自己的指令集（即字节码）并映射到本地的CPU的指令集或OS的系统调用。Java面对不同操作系统使用不同的虚拟机，依次实现了跨平台。JVM对上层的Java源文件是不关心的，它关心的只是由源文件生成的类文件。 总结我们利用JDK（调用本地的API）开发属于自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解释这些字节码，映射到CPU指令集或OS的系统调用。JDK包含了JRE，JRE包含了JVM","categories":[{"name":"java基础","slug":"java基础","permalink":"https://qingqingxihuanlili.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://qingqingxihuanlili.github.io/tags/JVM/"},{"name":"JDK","slug":"JDK","permalink":"https://qingqingxihuanlili.github.io/tags/JDK/"},{"name":"JRE","slug":"JRE","permalink":"https://qingqingxihuanlili.github.io/tags/JRE/"}]},{"title":"idea配置maven","date":"2020-01-08T01:01:18.000Z","path":"2020/01/08/maven的安装和idea下的maven配置/","text":"maven介绍Apache Maven是一种创新的软件项目管理工具，提供了一个项目对象模型（POM）文件的新概念来管理项目的构建，相关性和文档。最强大的功能就是能够自动下载项目依赖库。它是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。 maven工程构建的优点：1、一个命令就可以完成构建、运行。2、maven对每个构建阶段进行规范，非常有利于大型团队协作开发。 maven项目管理所依赖的jar包不需要手动向工程添加jar包，只需要在pom.xml（maven工程的配置文件）添加jar包的坐标，自动从maven仓库中下载jar包、运行. 使用maven依赖管理添加jar的好处：1、通过pom.xml文件对jar包的版本进行统一管理，可避免版本冲突。2、maven团队维护了一个非常全的maven仓库，里边包括了当前使用的jar包，maven工程可以自动从maven仓库下载jar包，非常方便。 maven是基于java的，安装maven之前要先安装JDK。 安装mavenMaven的下载页面：http://maven.apache.org/download.html 下载自己想下载的版本，我下载的是apache-maven-3.6.3-bin.zip下载之后解压到对应的文件夹。安装就算完成了，接下来配置环境变量。 配置maven环境变量右键 “计算机”，选择 “属性”，之后点击 “高级系统设置”，点击”环境变量”，来设置环境变量，有以下系统变量需要配置： 新建系统变量 MAVEN_HOME，变量值：D:\\maven\\apache-maven-3.6.3地址是你maven的根目录 编辑系统变量 Path，添加变量值：;%MAVEN_HOME%\\bin查看是否配置成功可在黑窗口中输入 mvn –v 出现如下图所示说明配置成功,注意系统变量和用户变量。 maven仓库maven的工作需要从仓库下载一些jar包，本地的项目都会通过maven软件从远程仓库（可以理解为互联网上的仓库）下载jar包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此jar包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。最开始的时,本地仓库是不存在的当第一次执行maven命令的时候才被创建。现在介绍maven的一些其他配置 首先在我们安装maven的同级目录下创建一个空文件夹和一个配置文件 然后我们在配置文件里写入以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;pluginGroups /&gt; &lt;proxies /&gt; &lt;servers /&gt; &lt;localRepository&gt;D:/maven/localRepository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;google-maven-central&lt;/id&gt; &lt;name&gt;Google Maven Central&lt;/name&gt; &lt;url&gt;https://maven-central.storage.googleapis.com &lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 都写好之后，maven的配置就算是完成了，接下来打开idea那里还有配置… idea下的maven开发首先先打开idea的设置并找到maven的配置 修改掉idea默认的maven配置并把地址换成我们自己的。 之后找到maven–&gt;Runner,添加如下内容-Xms128m -Xmx512m -Duser.language=zh -Dfile.encoding=UTF-8 之后找到maven–&gt;Remote Jar Repostiores,添加如下内容 到此在idea上面maven的配置就算完成了。然后我们创建一个maven项目，选择maven项目 现在就可以编写代码了。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://qingqingxihuanlili.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"},{"name":"maven","slug":"maven","permalink":"https://qingqingxihuanlili.github.io/tags/maven/"}]},{"title":"idea配置jdk和tomcat","date":"2020-01-08T01:00:10.000Z","path":"2020/01/08/idea配置jdk-tomcat/","text":"安装JDK学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程：JDK下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index.html之后选择版本download，然后进入对应的JDK版本，选择接受协议并选好要下载的格式，包括对应系统选择，文件格式选择。然后点击下载 下载完成的图片 双击文件进行安装即可，需要注意的是安装过程中，还需要安装JRE 如图所示，选择要安装的位置，我们先把JRE装好，之后JDK会自动继续安装。至于JDK和JRE的区别，我在其他地方有提到了。 之后安装完成 然后我们还需要配置环境变量，右键计算机打开属性，选择高级系统设置 之后选择环境变量 我们首先新建一个名字为JAVA_HOME的变量，点击新建用户变量或者系统变量都可。 如图所示，地址填写你安装的JDK的根地址。在这路径下你应该能够找到bin、lib等目录。 之后还要新建一个名字是CLASSPATH的变量 变量名：CLASSPATH变量值：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 最前面的 “.;“句号分号不要忘记了。这个是告诉JDK，搜索CLASS时先查找当前目录的CLASS文件。这是由于Linux的安全机制引起的，LINUX用户很明白，WINDOWS用户就很难理解(因为WINDOWS默认的搜索顺序是先搜索当前目录的，再搜索系统目录的，再搜索PATH环境变量设定的)。 为什么CLASSPATH后面指定了tools.jar这个具体文件？这个是由java语言的import机制和jar机制决定的 之后新建Path或者也可以编辑系统的Path 变量名：Path变量值：%JAVA_HOME%\\bin; %JAVA_HOME%\\jre\\bin; 之后不出意外的话你的JDK配置就成功了，出意外的话，我也没有办法… 安装tomcattomcat的安装相对简单一些，因为我装的是免安装版本的。官网地址为：https://tomcat.apache.org/选择自己喜欢的版本下载吧，有解压版和安装版，我选择的是解压版。 如图然后我们选择一个适合它的地方，解压搞定！安好了 这个是点击bin目录下的startup.bat文件，打开localhost:8080就可以打开这个页面了。 idea配置JDKidea其实自己有自带JDK版本，但是如果我们想用自己的需要进行如下配置。点击File –&gt;Project Structure； 进入Project Structure选择SDKs，左上角的加号新增一个我们自己的JDK 。选择我们在本地的JDK地址 然后点击OK，配置成功！ idea配置tomcat点击Run –&gt;Edit Configurations； 进入Edit Configurations选择左上角的加号新增一个我们自己的tomcat本地服务器。 之后路径定义成我们本地服务器的路径就可以了","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://qingqingxihuanlili.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"},{"name":"jdk","slug":"jdk","permalink":"https://qingqingxihuanlili.github.io/tags/jdk/"},{"name":"tomcat","slug":"tomcat","permalink":"https://qingqingxihuanlili.github.io/tags/tomcat/"}]},{"title":"IntelliJ IDEA下载安装","date":"2020-01-07T01:08:07.000Z","path":"2020/01/07/IntelliJ IDEA下载安装/","text":"下载地址：https://www.jetbrains.com/idea/download/#section=windows记得选择旗舰版UItimate,因为社区版缺少了很多功能。当然下载安装完成之后我们还要对旗舰版进行破解。 安装下载完成之后，直接双击.exe运行文件，点击Next则选择的是默认的一个安装路径；或者点击“Browse”,自己设置路径，之后点击“Next”; 如果是64位记得勾选 之后点击安装就可以了 破解不破解的话会有30天的免费试用，破解的话我只试过用激活码破解，但是现在激活码也比较难找了。 破解完成之后就可以进入我们开发工具了 至此IntelliJ IDEA的安装就算完成了。记得去设置里面调自己喜欢的风格，而且不建议汉化！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"jetbrains","slug":"jetbrains","permalink":"https://qingqingxihuanlili.github.io/tags/jetbrains/"},{"name":"idea","slug":"idea","permalink":"https://qingqingxihuanlili.github.io/tags/idea/"}]},{"title":"WebStorm下载安装","date":"2020-01-07T01:07:53.000Z","path":"2020/01/07/WebStorm下载安装/","text":"下载下载地址： www.jetbrains.com/webstorm/(最新版) 下载地址： www.jetbrains.com/webstorm/do…（其他版本） 安装下载完成之后，直接双击.exe运行文件，点击Next则选择的是默认的一个安装路径；或者点击“Browse”,自己设置路径，之后点击“Next”; 如果是64位记得勾选 之后点击安装就可以了 破解不破解的话会有30天的免费试用，破解的话我只试过用激活码破解，但是现在激活码也比较难找了。 破解完成之后就可以进入我们开发工具了 至此webstorm的安装就算完成了。记得去设置里面调自己喜欢的风格，而且不建议汉化！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"jetbrains","slug":"jetbrains","permalink":"https://qingqingxihuanlili.github.io/tags/jetbrains/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://qingqingxihuanlili.github.io/tags/WebStorm/"}]},{"title":"谷歌访问助手安装和使用","date":"2020-01-07T01:06:36.000Z","path":"2020/01/07/谷歌访问助手安装说明/","text":"前言我们先来看一下google搜索和百度搜索的区别。你在google面前可以看到整个互联网，而当你打开百度，只能看到遮遮掩掩的中国局域网。google会给你你想要的，而百度会给你它想给你的。对于广告来说，每次用百度搜索都要下拉几条才可以看，因为前面几条都是广告。以前我使用的也是百度，后来接触到了google，然后…就使用google了，不得不说对于开发的人员来说，google给到的帮助实在是太大了。可是在国内你需要翻墙后才能访问和下载各种谷歌相关的内容，有没有不需要翻墙就可以简单的访问google的方法呢？ 还好谷歌的应用商店有着一款谷歌访问助手的插件，但是问题又来了，谷歌的应用商店我们也访问不到…还好，我们可以不用访问应用商店安装~ 下载下载的话，我这里有一个链接链接：https://pan.baidu.com/s/1hfurXLsL0XeK5iLw8eOa7g提取码：ngaf复制这段内容后打开百度网盘手机App，操作更方便哦你下载到的是一个.zip的压缩文件，之后我们把它解压缩，就像这样。 之后，打开我们的谷歌浏览器，看到最上角的三个小点了吗？ 点一下，打开更多工具的扩展程序，右上角有一个开发者模式，把它打开。 打开之后我们就能看到一行新增的菜单，分别是加载已解压的扩展程序，打包扩展程序，更新。我们选择已加载的扩展程序，选择我们刚刚下载好的谷歌访问助手.crx文件（所在的整个文件夹），或者是直接把crx文件拖拽到页面。到此我们就算安装好了 失败解决方案如果你失败了，那请接着往下看。首先啊，你把那个插件.crx的后缀改成.rar。忽略告警提示， 之后把这个rar文件在解压一次，然后选择已加载的扩展程序，选择这个新解压的文件夹应该就能安装成功了。之前的那一堆就可以删掉了。 安装之后安装之后，会提示你激活的，当然是免费的，免费的条件居然是设置hao123为主页！点击免费激活，在点击蓝色的选项也设置，之后设置网页就可以了。 现在，我们的google就真的安装好了。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://qingqingxihuanlili.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"谷歌浏览器","slug":"谷歌浏览器","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"谷歌访问助手","slug":"谷歌访问助手","permalink":"https://qingqingxihuanlili.github.io/tags/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/"}]}]